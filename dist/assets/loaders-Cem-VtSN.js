import{L as q,F as J,B as T,a as I,C as W,S as G,G as $,b as S,M as D,P as R,c as K,d as O,e as B,f as k,V as A}from"./three-s0w8xr1i.js";const C=new W;class ie extends q{constructor(t){super(t),this.propertyNameMapping={},this.customPropertyMapping={}}load(t,s,u,n){const l=this,d=new J(this.manager);d.setPath(this.path),d.setResponseType("arraybuffer"),d.setRequestHeader(this.requestHeader),d.setWithCredentials(this.withCredentials),d.load(t,function(y){try{s(l.parse(y))}catch(V){n?n(V):console.error(V),l.manager.itemError(t)}},u,n)}setPropertyNameMapping(t){this.propertyNameMapping=t}setCustomPropertyNameMapping(t){this.customPropertyMapping=t}parse(t){function s(e,o=0){const r=/^ply([\s\S]*)end_header(\r\n|\r|\n)/;let i="";const a=r.exec(e);a!==null&&(i=a[1]);const p={comments:[],elements:[],headerLength:o,objInfo:""},c=i.split(/\r\n|\r|\n/);let h;function P(_,L){const v={type:_[0]};return v.type==="list"?(v.name=_[3],v.countType=_[1],v.itemType=_[2]):v.name=_[1],v.name in L&&(v.name=L[v.name]),v}for(let _=0;_<c.length;_++){let L=c[_];if(L=L.trim(),L==="")continue;const v=L.split(/\s+/),U=v.shift();switch(L=v.join(" "),U){case"format":p.format=v[0],p.version=v[1];break;case"comment":p.comments.push(L);break;case"element":h!==void 0&&p.elements.push(h),h={},h.name=v[0],h.count=parseInt(v[1]),h.properties=[];break;case"property":h.properties.push(P(v,g.propertyNameMapping));break;case"obj_info":p.objInfo=L;break;default:console.log("unhandled",U,v)}}return h!==void 0&&p.elements.push(h),p}function u(e,o){switch(o){case"char":case"uchar":case"short":case"ushort":case"int":case"uint":case"int8":case"uint8":case"int16":case"uint16":case"int32":case"uint32":return parseInt(e);case"float":case"double":case"float32":case"float64":return parseFloat(e)}}function n(e,o){const r={};for(let i=0;i<e.length;i++){if(o.empty())return null;if(e[i].type==="list"){const a=[],p=u(o.next(),e[i].countType);for(let c=0;c<p;c++){if(o.empty())return null;a.push(u(o.next(),e[i].itemType))}r[e[i].name]=a}else r[e[i].name]=u(o.next(),e[i].type)}return r}function l(){const e={indices:[],vertices:[],normals:[],uvs:[],faceVertexUvs:[],colors:[],faceVertexColors:[]};for(const o of Object.keys(g.customPropertyMapping))e[o]=[];return e}function d(e){const o=e.map(i=>i.name);function r(i){for(let a=0,p=i.length;a<p;a++){const c=i[a];if(o.includes(c))return c}return null}return{attrX:r(["x","px","posx"])||"x",attrY:r(["y","py","posy"])||"y",attrZ:r(["z","pz","posz"])||"z",attrNX:r(["nx","normalx"]),attrNY:r(["ny","normaly"]),attrNZ:r(["nz","normalz"]),attrS:r(["s","u","texture_u","tx"]),attrT:r(["t","v","texture_v","ty"]),attrR:r(["red","diffuse_red","r","diffuse_r"]),attrG:r(["green","diffuse_green","g","diffuse_g"]),attrB:r(["blue","diffuse_blue","b","diffuse_b"])}}function y(e,o){const r=l(),i=/end_header\s+(\S[\s\S]*\S|\S)\s*$/;let a,p;(p=i.exec(e))!==null?a=p[1].split(/\s+/):a=[];const c=new Q(a);e:for(let h=0;h<o.elements.length;h++){const P=o.elements[h],_=d(P.properties);for(let L=0;L<P.count;L++){const v=n(P.properties,c);if(!v)break e;m(r,P.name,v,_)}}return V(r)}function V(e){let o=new T;e.indices.length>0&&o.setIndex(e.indices),o.setAttribute("position",new I(e.vertices,3)),e.normals.length>0&&o.setAttribute("normal",new I(e.normals,3)),e.uvs.length>0&&o.setAttribute("uv",new I(e.uvs,2)),e.colors.length>0&&o.setAttribute("color",new I(e.colors,3)),(e.faceVertexUvs.length>0||e.faceVertexColors.length>0)&&(o=o.toNonIndexed(),e.faceVertexUvs.length>0&&o.setAttribute("uv",new I(e.faceVertexUvs,2)),e.faceVertexColors.length>0&&o.setAttribute("color",new I(e.faceVertexColors,3)));for(const r of Object.keys(g.customPropertyMapping))e[r].length>0&&o.setAttribute(r,new I(e[r],g.customPropertyMapping[r].length));return o.computeBoundingSphere(),o}function m(e,o,r,i){if(o==="vertex"){e.vertices.push(r[i.attrX],r[i.attrY],r[i.attrZ]),i.attrNX!==null&&i.attrNY!==null&&i.attrNZ!==null&&e.normals.push(r[i.attrNX],r[i.attrNY],r[i.attrNZ]),i.attrS!==null&&i.attrT!==null&&e.uvs.push(r[i.attrS],r[i.attrT]),i.attrR!==null&&i.attrG!==null&&i.attrB!==null&&(C.setRGB(r[i.attrR]/255,r[i.attrG]/255,r[i.attrB]/255,G),e.colors.push(C.r,C.g,C.b));for(const a of Object.keys(g.customPropertyMapping))for(const p of g.customPropertyMapping[a])e[a].push(r[p])}else if(o==="face"){const a=r.vertex_indices||r.vertex_index,p=r.texcoord;a.length===3?(e.indices.push(a[0],a[1],a[2]),p&&p.length===6&&(e.faceVertexUvs.push(p[0],p[1]),e.faceVertexUvs.push(p[2],p[3]),e.faceVertexUvs.push(p[4],p[5]))):a.length===4&&(e.indices.push(a[0],a[1],a[3]),e.indices.push(a[1],a[2],a[3])),i.attrR!==null&&i.attrG!==null&&i.attrB!==null&&(C.setRGB(r[i.attrR]/255,r[i.attrG]/255,r[i.attrB]/255,G),e.faceVertexColors.push(C.r,C.g,C.b),e.faceVertexColors.push(C.r,C.g,C.b),e.faceVertexColors.push(C.r,C.g,C.b))}}function j(e,o){const r={};let i=0;for(let a=0;a<o.length;a++){const p=o[a],c=p.valueReader;if(p.type==="list"){const h=[],P=p.countReader.read(e+i);i+=p.countReader.size;for(let _=0;_<P;_++)h.push(c.read(e+i)),i+=c.size;r[p.name]=h}else r[p.name]=c.read(e+i),i+=c.size}return[r,i]}function f(e,o,r){function i(a,p,c){switch(p){case"int8":case"char":return{read:h=>a.getInt8(h),size:1};case"uint8":case"uchar":return{read:h=>a.getUint8(h),size:1};case"int16":case"short":return{read:h=>a.getInt16(h,c),size:2};case"uint16":case"ushort":return{read:h=>a.getUint16(h,c),size:2};case"int32":case"int":return{read:h=>a.getInt32(h,c),size:4};case"uint32":case"uint":return{read:h=>a.getUint32(h,c),size:4};case"float32":case"float":return{read:h=>a.getFloat32(h,c),size:4};case"float64":case"double":return{read:h=>a.getFloat64(h,c),size:8}}}for(let a=0,p=e.length;a<p;a++){const c=e[a];c.type==="list"?(c.countReader=i(o,c.countType,r),c.valueReader=i(o,c.itemType,r)):c.valueReader=i(o,c.type,r)}}function x(e,o){const r=l(),i=o.format==="binary_little_endian",a=new DataView(e,o.headerLength);let p,c=0;for(let h=0;h<o.elements.length;h++){const P=o.elements[h],_=P.properties,L=d(_);f(_,a,i);for(let v=0;v<P.count;v++){p=j(c,_),c+=p[1];const U=p[0];m(r,P.name,U,L)}}return V(r)}function w(e){let o=0,r=!0,i="";const a=[],p=new TextDecoder().decode(e.subarray(0,5)),c=/^ply\r\n/.test(p);do{const h=String.fromCharCode(e[o++]);h!==`
`&&h!=="\r"?i+=h:(i==="end_header"&&(r=!1),i!==""&&(a.push(i),i=""))}while(r&&o<e.length);return c===!0&&o++,{headerText:a.join("\r")+"\r",headerLength:o}}let b;const g=this;if(t instanceof ArrayBuffer){const e=new Uint8Array(t),{headerText:o,headerLength:r}=w(e),i=s(o,r);if(i.format==="ascii"){const a=new TextDecoder().decode(e);b=y(a,i)}else b=x(t,i)}else b=y(t,s(t));return b}}class Q{constructor(t){this.arr=t,this.i=0}empty(){return this.i>=this.arr.length}next(){return this.arr[this.i++]}}const E=/^[og]\s*(.+)?/,ee=/^mtllib /,te=/^usemtl /,se=/^usemap /,H=/\s+/,Y=new A,F=new A,X=new A,Z=new A,z=new A,N=new W;function ne(){const M={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materials:{},materialLibraries:[],startObject:function(t,s){if(this.object&&this.object.fromDeclaration===!1){this.object.name=t,this.object.fromDeclaration=s!==!1;return}const u=this.object&&typeof this.object.currentMaterial=="function"?this.object.currentMaterial():void 0;if(this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0),this.object={name:t||"",fromDeclaration:s!==!1,geometry:{vertices:[],normals:[],colors:[],uvs:[],hasUVIndices:!1},materials:[],smooth:!0,startMaterial:function(n,l){const d=this._finalize(!1);d&&(d.inherited||d.groupCount<=0)&&this.materials.splice(d.index,1);const y={index:this.materials.length,name:n||"",mtllib:Array.isArray(l)&&l.length>0?l[l.length-1]:"",smooth:d!==void 0?d.smooth:this.smooth,groupStart:d!==void 0?d.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(V){const m={index:typeof V=="number"?V:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return m.clone=this.clone.bind(m),m}};return this.materials.push(y),y},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(n){const l=this.currentMaterial();if(l&&l.groupEnd===-1&&(l.groupEnd=this.geometry.vertices.length/3,l.groupCount=l.groupEnd-l.groupStart,l.inherited=!1),n&&this.materials.length>1)for(let d=this.materials.length-1;d>=0;d--)this.materials[d].groupCount<=0&&this.materials.splice(d,1);return n&&this.materials.length===0&&this.materials.push({name:"",smooth:this.smooth}),l}},u&&u.name&&typeof u.clone=="function"){const n=u.clone(0);n.inherited=!0,this.object.materials.push(n)}this.objects.push(this.object)},finalize:function(){this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0)},parseVertexIndex:function(t,s){const u=parseInt(t,10);return(u>=0?u-1:u+s/3)*3},parseNormalIndex:function(t,s){const u=parseInt(t,10);return(u>=0?u-1:u+s/3)*3},parseUVIndex:function(t,s){const u=parseInt(t,10);return(u>=0?u-1:u+s/2)*2},addVertex:function(t,s,u){const n=this.vertices,l=this.object.geometry.vertices;l.push(n[t+0],n[t+1],n[t+2]),l.push(n[s+0],n[s+1],n[s+2]),l.push(n[u+0],n[u+1],n[u+2])},addVertexPoint:function(t){const s=this.vertices;this.object.geometry.vertices.push(s[t+0],s[t+1],s[t+2])},addVertexLine:function(t){const s=this.vertices;this.object.geometry.vertices.push(s[t+0],s[t+1],s[t+2])},addNormal:function(t,s,u){const n=this.normals,l=this.object.geometry.normals;l.push(n[t+0],n[t+1],n[t+2]),l.push(n[s+0],n[s+1],n[s+2]),l.push(n[u+0],n[u+1],n[u+2])},addFaceNormal:function(t,s,u){const n=this.vertices,l=this.object.geometry.normals;Y.fromArray(n,t),F.fromArray(n,s),X.fromArray(n,u),z.subVectors(X,F),Z.subVectors(Y,F),z.cross(Z),z.normalize(),l.push(z.x,z.y,z.z),l.push(z.x,z.y,z.z),l.push(z.x,z.y,z.z)},addColor:function(t,s,u){const n=this.colors,l=this.object.geometry.colors;n[t]!==void 0&&l.push(n[t+0],n[t+1],n[t+2]),n[s]!==void 0&&l.push(n[s+0],n[s+1],n[s+2]),n[u]!==void 0&&l.push(n[u+0],n[u+1],n[u+2])},addUV:function(t,s,u){const n=this.uvs,l=this.object.geometry.uvs;l.push(n[t+0],n[t+1]),l.push(n[s+0],n[s+1]),l.push(n[u+0],n[u+1])},addDefaultUV:function(){const t=this.object.geometry.uvs;t.push(0,0),t.push(0,0),t.push(0,0)},addUVLine:function(t){const s=this.uvs;this.object.geometry.uvs.push(s[t+0],s[t+1])},addFace:function(t,s,u,n,l,d,y,V,m){const j=this.vertices.length;let f=this.parseVertexIndex(t,j),x=this.parseVertexIndex(s,j),w=this.parseVertexIndex(u,j);if(this.addVertex(f,x,w),this.addColor(f,x,w),y!==void 0&&y!==""){const b=this.normals.length;f=this.parseNormalIndex(y,b),x=this.parseNormalIndex(V,b),w=this.parseNormalIndex(m,b),this.addNormal(f,x,w)}else this.addFaceNormal(f,x,w);if(n!==void 0&&n!==""){const b=this.uvs.length;f=this.parseUVIndex(n,b),x=this.parseUVIndex(l,b),w=this.parseUVIndex(d,b),this.addUV(f,x,w),this.object.geometry.hasUVIndices=!0}else this.addDefaultUV()},addPointGeometry:function(t){this.object.geometry.type="Points";const s=this.vertices.length;for(let u=0,n=t.length;u<n;u++){const l=this.parseVertexIndex(t[u],s);this.addVertexPoint(l),this.addColor(l)}},addLineGeometry:function(t,s){this.object.geometry.type="Line";const u=this.vertices.length,n=this.uvs.length;for(let l=0,d=t.length;l<d;l++)this.addVertexLine(this.parseVertexIndex(t[l],u));for(let l=0,d=s.length;l<d;l++)this.addUVLine(this.parseUVIndex(s[l],n))}};return M.startObject("",!1),M}class oe extends q{constructor(t){super(t),this.materials=null}load(t,s,u,n){const l=this,d=new J(this.manager);d.setPath(this.path),d.setRequestHeader(this.requestHeader),d.setWithCredentials(this.withCredentials),d.load(t,function(y){try{s(l.parse(y))}catch(V){n?n(V):console.error(V),l.manager.itemError(t)}},u,n)}setMaterials(t){return this.materials=t,this}parse(t){const s=new ne;t.indexOf(`\r
`)!==-1&&(t=t.replace(/\r\n/g,`
`)),t.indexOf(`\\
`)!==-1&&(t=t.replace(/\\\n/g,""));const u=t.split(`
`);let n=[];for(let y=0,V=u.length;y<V;y++){const m=u[y].trimStart();if(m.length===0)continue;const j=m.charAt(0);if(j!=="#")if(j==="v"){const f=m.split(H);switch(f[0]){case"v":s.vertices.push(parseFloat(f[1]),parseFloat(f[2]),parseFloat(f[3])),f.length>=7?(N.setRGB(parseFloat(f[4]),parseFloat(f[5]),parseFloat(f[6]),G),s.colors.push(N.r,N.g,N.b)):s.colors.push(void 0,void 0,void 0);break;case"vn":s.normals.push(parseFloat(f[1]),parseFloat(f[2]),parseFloat(f[3]));break;case"vt":s.uvs.push(parseFloat(f[1]),parseFloat(f[2]));break}}else if(j==="f"){const x=m.slice(1).trim().split(H),w=[];for(let g=0,e=x.length;g<e;g++){const o=x[g];if(o.length>0){const r=o.split("/");w.push(r)}}const b=w[0];for(let g=1,e=w.length-1;g<e;g++){const o=w[g],r=w[g+1];s.addFace(b[0],o[0],r[0],b[1],o[1],r[1],b[2],o[2],r[2])}}else if(j==="l"){const f=m.substring(1).trim().split(" ");let x=[];const w=[];if(m.indexOf("/")===-1)x=f;else for(let b=0,g=f.length;b<g;b++){const e=f[b].split("/");e[0]!==""&&x.push(e[0]),e[1]!==""&&w.push(e[1])}s.addLineGeometry(x,w)}else if(j==="p"){const x=m.slice(1).trim().split(" ");s.addPointGeometry(x)}else if((n=E.exec(m))!==null){const f=(" "+n[0].slice(1).trim()).slice(1);s.startObject(f)}else if(te.test(m))s.object.startMaterial(m.substring(7).trim(),s.materialLibraries);else if(ee.test(m))s.materialLibraries.push(m.substring(7).trim());else if(se.test(m))console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if(j==="s"){if(n=m.split(" "),n.length>1){const x=n[1].trim().toLowerCase();s.object.smooth=x!=="0"&&x!=="off"}else s.object.smooth=!0;const f=s.object.currentMaterial();f&&(f.smooth=s.object.smooth)}else{if(m==="\0")continue;console.warn('THREE.OBJLoader: Unexpected line: "'+m+'"')}}s.finalize();const l=new $;if(l.materialLibraries=[].concat(s.materialLibraries),!(s.objects.length===1&&s.objects[0].geometry.vertices.length===0)===!0)for(let y=0,V=s.objects.length;y<V;y++){const m=s.objects[y],j=m.geometry,f=m.materials,x=j.type==="Line",w=j.type==="Points";let b=!1;if(j.vertices.length===0)continue;const g=new T;g.setAttribute("position",new I(j.vertices,3)),j.normals.length>0&&g.setAttribute("normal",new I(j.normals,3)),j.colors.length>0&&(b=!0,g.setAttribute("color",new I(j.colors,3))),j.hasUVIndices===!0&&g.setAttribute("uv",new I(j.uvs,2));const e=[];for(let r=0,i=f.length;r<i;r++){const a=f[r],p=a.name+"_"+a.smooth+"_"+b;let c=s.materials[p];if(this.materials!==null){if(c=this.materials.create(a.name),x&&c&&!(c instanceof S)){const h=new S;D.prototype.copy.call(h,c),h.color.copy(c.color),c=h}else if(w&&c&&!(c instanceof R)){const h=new R({size:10,sizeAttenuation:!1});D.prototype.copy.call(h,c),h.color.copy(c.color),h.map=c.map,c=h}}c===void 0&&(x?c=new S:w?c=new R({size:1,sizeAttenuation:!1}):c=new K,c.name=a.name,c.flatShading=!a.smooth,c.vertexColors=b,s.materials[p]=c),e.push(c)}let o;if(e.length>1){for(let r=0,i=f.length;r<i;r++){const a=f[r];g.addGroup(a.groupStart,a.groupCount,r)}x?o=new O(g,e):w?o=new B(g,e):o=new k(g,e)}else x?o=new O(g,e[0]):w?o=new B(g,e[0]):o=new k(g,e[0]);o.name=m.name,l.add(o)}else if(s.vertices.length>0){const y=new R({size:1,sizeAttenuation:!1}),V=new T;V.setAttribute("position",new I(s.vertices,3)),s.colors.length>0&&s.colors[0]!==void 0&&(V.setAttribute("color",new I(s.colors,3)),y.vertexColors=!0);const m=new B(V,y);l.add(m)}return l}}export{oe as O,ie as P};
